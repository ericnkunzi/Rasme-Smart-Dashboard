<script>
  // Color map stays the same
  const sectorColors = {
    "Water & Sanitation": "#007bff",  // blue
    Energy: "#28a745",                 // green
    Transport: "#ffc107",              // yellow
  };

  // Normalize various sector name variants to one standard string
  function normalizeSector(sector) {
    if (!sector) return "Unknown";

    const s = sector.toLowerCase().trim();

    // Normalize all water-related variations to "Water & Sanitation"
    if (
      s === "water & sanitation" ||
      s === "water & sanitation" ||
      s === "water & sanitation" ||
      s === "water & sanitation" ||
      s === "water and sanitation" ||
      s === "water sanitation" ||
      s === "water" ||
      s === "water & sanitation" ||
      s === "water & sanitation"
    ) {
      return "Water & Sanitation";
    }

    // Normalize Energy
    if (s === "energy") return "Energy";

    // Normalize Transport
    if (s === "transport") return "Transport";

    // For anything else, return as-is but capitalized nicely (optional)
    return sector;
  }

  // Update sector progress bars with normalized sector names
  function updateSectorBars(data) {
    const counts = {
      "Water & Sanitation": 0,
      Energy: 0,
      Transport: 0,
    };

    data.forEach(({ sector }) => {
      const normalized = normalizeSector(sector);
      if (counts[normalized] !== undefined) {
        counts[normalized]++;
      }
    });

    const total = data.length || 1;

    for (const sector in counts) {
      const count = counts[sector];
      const percent = Math.round((count / total) * 100);

      // ID in HTML is sector name with lowercase and no spaces or special chars
      const barId = sector.toLowerCase().replace(/ & /g, "").replace(/\s/g, "") + "Bar";
      const percentId = sector.toLowerCase().replace(/ & /g, "").replace(/\s/g, "") + "Percent";

      const bar = document.getElementById(barId);
      const percentLabel = document.getElementById(percentId);

      if (bar && percentLabel) {
        bar.style.width = percent + "%";
        percentLabel.textContent = percent + "%";
      }
    }
  }

  // Add markers to map with normalized sectors and color assignment
  function addMarkers(data) {
    data.forEach((item) => {
      const sector = normalizeSector(item.sector);
      const color = sectorColors[sector] || "#333";

      if (item.latitude && item.longitude && sectorColors[sector]) {
        L.circleMarker([item.latitude, item.longitude], {
          radius: 6,
          color: color,
          fillColor: color,
          fillOpacity: 0.7,
          weight: 1.5,
        })
          .bindPopup(
            `<b>Collector:</b> ${item.collector}<br />
             <b>Sector:</b> ${sector}<br />
             <b>Date:</b> ${new Date(item.date).toLocaleDateString()}`
          )
          .addTo(map);
      }
    });
  }

  // Update Top Data Collectors table with normalized sectors
  function updateCollectorsTable(data) {
    // Group by collector and sector, but normalize sector names
    const collectorMap = {};

    data.forEach((item) => {
      const collector = item.collector || "Unknown";
      const sector = normalizeSector(item.sector);

      if (!collectorMap[collector]) {
        collectorMap[collector] = {};
      }

      if (!collectorMap[collector][sector]) {
        collectorMap[collector][sector] = 0;
      }

      collectorMap[collector][sector]++;
    });

    // Clear previous table body
    const tbody = document.getElementById("collectorsTableBody");
    tbody.innerHTML = "";

    // Convert collectorMap to array of collectors with total submissions and sector counts
    const collectorArray = Object.entries(collectorMap).map(([collector, sectors]) => {
      let total = 0;
      for (const count of Object.values(sectors)) {
        total += count;
      }
      return { collector, sectors, total };
    });

    // Sort by total descending
    collectorArray.sort((a, b) => b.total - a.total);

    // Build table rows with sector data replaced accordingly
    collectorArray.forEach(({ collector, sectors, total }) => {
      const row = document.createElement("tr");

      const collectorCell = document.createElement("td");
      collectorCell.textContent = collector;
      row.appendChild(collectorCell);

      // Create one cell per sector (Water & Sanitation, Energy, Transport)
      ["Water & Sanitation", "Energy", "Transport"].forEach((sectorName) => {
        const cell = document.createElement("td");
        cell.textContent = sectors[sectorName] || 0;
        row.appendChild(cell);
      });

      // Total submissions cell
      const totalCell = document.createElement("td");
      totalCell.textContent = total;
      row.appendChild(totalCell);

      tbody.appendChild(row);
    });
  }

  // Example data loading & rendering function, keep your existing logic
  async function loadDataAndRender() {
    const data = await fetchDataFromAPI(); // Your existing API fetch, unchanged

    // Normalize and update UI parts with normalized data
    updateSectorBars(data);
    updateCollectorsTable(data);
    addMarkers(data);

    // Other UI updates remain as is
  }

  // Call loadDataAndRender somewhere in your code as before
</script>
